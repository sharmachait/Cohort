we rarely create our own async function, an ugly way to write wrappers is this
```js
const fs=require("fs");

function myUglyAsync(callback){
	fs.readFile("file name", "utf-8", function(err,data){callback(data);} );
}

function callback(data){
	console.log(data);
}
```
better way is to use promises
```js
const fs=require("fs");

function myPrettyAsync(){
	return new Promise(function(resolve){
			fs.readFile("file name", "utf-8", function(err,data){
												resolve(data);
												}
			);
	});
}

function callback(data){console.log(data)};

myPrettyAsync().then(callback);
```
promises are either resolved or rejected
the reject function is optional and we can pass any message to the issuer of the promise 
what ever function we pass inside the .then() is treated as the resolve callback
what ever function we pass inside the .catch() is treated as the reject callback 

.then() doesnt block the thread
syntax
```js
new Promise(function(resolve,reject){do somethign and then resolve()});
```
calling .then() on a new promise just adds the call back to the pipeline, which will execute when ever the control reaches to the resolve() in the promise

the following piece of code will print "hi"

```js
const fs = require("fs");

function myPrettyAsync() {
	return new Promise(function (WhenComplete) {
			console.log('hi')
			fs.readFile("harkirat.docx", "utf-8", function (err, data) {
				WhenComplete(data);
			}
		);
	});
}

function callback(data) { console.log(data) };

myPrettyAsync()//.then(callback);
```

just a pretty way to call async functions
under the hood it still uses the call stack the call back queue and the event stack
most of the time we only create a wrapper on a async function like on fetch
we pass the promise constructor an anonymous function taking a callback
and the callback takes a json object

that is the promise -> anonymous function -> callbacks -> json 

in the call back we define we can only pass one thing from the promise so if we want to pass multiple things we need to pass an object or list

```js
function myPrettyAsync() {
    return new Promise(function (resolve) {
        console.log('hi')
        let a = "you called .then()";
        let idx = 5;
        for (let i = 0; i < 1000000000; i++) {
            if (i == 50000000) {
                resolve({ data: a, index: i });
           }
        }
    });
}
 
function callback(result) {
    console.log(result.data);
    console.log(result.index);
}
myPrettyAsync().then(callback);
console.log('after');
```

the above code prints 
- hi
- after 
- you called .then()
- 50000000

everything happens synchronously and the callbacks are just put into the callback queue, and are picked up when the thread is free

"you called .then()" and then 5 are not printed if we dont do .then
###### states of promise
1. pending - state until the .then() is called
2. resolved - state when the .then() is called
3. rejected

![[Pasted image 20240111114628.png]]




we can run all the promises together without like so
```js
Promise.all([promise1,promise2,promise3]).then((resolved_messages)=>{});
```
this will run all the promises and call the .then() and .catch() methods for us on all of em
and the .then() receives the resolution from all of the promises that means if all of them were resolve("some string") we can iterate the outer .then parameter that is

```js
const promise1 = new Promise((resolve, reject) => { resolve("promise1"); });
const promise2 = new Promise((resolve, reject) => { resolve("promise2"); });
const promise3 = new Promise((resolve, reject) => { resolve("promise3"); });
Promise.all([promise1, promise2, promise3])
    .then((resolved_messages) => {
        console.log(resolved_messages);
        for (let message of resolved_messages) { console.log(message) }
    });
 ```
 