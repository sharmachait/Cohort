# Why Next
problems with react
1. at least 2 projects one for frontend and one for backend
2. no built in routing mechanism
3. not SEO optimized
	1. why? because the initial html is empty and is filled up as the user interacts with it, so the dummy bot crawlers are not able to rank SPA, hence not SEO optimized
	2. the content in SPA is dependent on the JS but the crawlers google uses, do not run the JS. they only look at the html
	3. solved because of server side rendering
4. waterfalling problem
	1. the request cycle takes a bunch of steps, even for a simple blob website
![[Pasted image 20240609172413.png]]
	2. all these requests dont happen parallelly
	3. this is known as the waterfalling problem
	4. solved due to server side rendering
## features
1. server side rendering (ssr)
2. API routes - full stack framework
3. file based routing
4. bundle size optimisation
5. static site generation (ssg)
## downsides
1. cant be distributed via a CDN, always needs a server running that does the server side rendering, therefore is expensive (for static sites ofcourse)
2. hard to migrate out of

# init
> npx create-next-app@latest

in it choose typescript, eslint, tailwind, and app router
## page metadata
the name of the tab and description can be exported from every page by exporting an object of type Metadata
```tsx
import type {Metadata} from 'next';

export const metadata:Metadata={
	title:"Page Name",
	description:"some description for the page for SEO optimization"
}
```
## file structure
folders inside the app folder will serve as the route and the page.tsx file at the folder level will be served
## server side response
when we go to a route we get the whole ass html for that route in the network tab
## dynamic routes
in a folder named like so `[...param]`
## layout.tsx file
used to wrap child pages in some logic
the layout file must default import a function like the other page files
the function must expect `Readonly<{children:React.ReactNode}>`, this refers to the component being exported from the page.tsx at the same level

basically wrap the child it received in some other html and logic and return wrapper jsx for the children

we can have layout.tsx at the same level as the page.jsx
describes the layout for all the subfolders from that level

can be used for stuff like nav bars
## server components
in next all components are server components by default.
they have the ability to read files or fetch data from database on the server
cant use hooks or handle user interactions
## client components
necessary to add the use client on top of the component file
can use hooks and manage interactions
## routing
everything in the app folder is routed
#### shared layouts
![[Pasted image 20240610111327.png]]
#### shared layouts without the auth being in the route
if we want a folder to not be part of the route use `(auth)`
![[Pasted image 20240610111606.png]]
now we can go to `app/signin` and all the routes under `(auth)` will have the same layout because 
## components page
we dont want every tsx file to be routed
like simple button or navbar components for that use the components folder to make files for them, they wont be routed by next.js
we can actually name the folder anything just make sure to include that folder in the tailwind config

### **we cant have on click handlers in the server side components and by default everything is server side in next.js**

if you want interactivity in a page put the `use client` directive on top of the file

server side components can not be children of of client side components
## backend
in next we fetch the data on the server side and pre render the page before returning it to the user
we can still do api calls for external apis
using useEffects will require us to make the component a client side component

#### server side data fetching and loaders
done using async components
```tsx
import axios from 'axios';  

const Page = async () => {  
	const res = await axios.get(  
		'https://week-13-offline.kirattechnologies.workers.dev/api/v1/user/details'  
	);  
	const data = res.data;  
	return (
		<div>
			{data.name}
		</div>
	);  
};  

export default Page;
```

notice the component function itself in asynchronous

the server side request may take a long time, and the client will have nothing to show in the meantime
add a spinner, **without hooks**
use a file called loading.tsx at the same level as the page.tsx server component
```tsx
const loading = () => {  
  return <div>loading...</div>;  
};  
export default loading;
```
![[Pasted image 20240611074417.png]]
we can see the effects clearly by adding an awaited time out int he function fetching our data
```tsx
await new Promise((r) => setTimeout(r, 5000));
```
like so
```tsx
import axios from 'axios';  
const Page = async () => {  
  const res = await axios.get(  
    'https://week-13-offline.kirattechnologies.workers.dev/api/v1/user/details'  
  );  
  await new Promise((r) => setTimeout(r, 5000));  
  const data = res.data;  
  return <div>{data.name}</div>;  
};  
export default Page;
```

#### Api in next.js
in the app folder create an api folder in that create a controller name folder like `app/api/user`
in that folder create a route.ts
this file will be treated as an api route because of the route.ts
in that file export a function called GET which will be the function where we receive control
```ts
import {NextResponse} from "next/server";  
  
export function GET() {  
  return NextResponse.json({  
    name: 'chaitanya',  
  });  
}
```
for body, headers, query parameters receive an object of type NextRequest in the function
but even without that we can go to 
`localhost:3000/api/user`
in the same file if we create a POST function we get a post endpoint at the same route
```ts
import { NextRequest, NextResponse } from 'next/server';  
  
export function GET() {  
  return NextResponse.json({  
    name: 'chaitanya',  
  });  
}  
  
export async function POST(req: NextRequest) {  
  let body = await req.json();  
  console.log({ body });  
  console.log(req.headers.get('token'));  
  console.log(req.nextUrl.searchParams.get('filter'));  
  return NextResponse.json({  
    name: 'chaitanya',  
  });  
}
```

as you can see we can get the 
- body using the `req.json()` function which returns a promise
- header params via `req.headers.get("key")`
- query parameters using `req.nextUrl.searchParams.get('filter')`

###### do we really need an api call to fetch data in a server side component? it is server side so we dont need it we can simply have the logic to read data from database in the server side component it self.
## server actions
if we want to ever hit an endpoint from the server, but we also need to hit it from some front end

basically do something that an endpoint does in some server side component, then we can create server actions which are functions we can call both at the frontend and at the backend

the bad way to do it is to do an http request from the backend to the backend
or we can abstract the logic out into server actions

if we have a server action we can completely get rid of the http endpoint

the client will send an http request only but the server action isnt exposed as an http endpoint, kinda like a grpc call

![[Pasted image 20240613120514.png]]
we can import the signup server action into the component and then call it from the frontend which will sort of send an http request from the frontend to the backend
but we wont have to write an axios.get or axios.post in the frontend

create another folder in the app folder called actions
create user.ts to write all the user actions
actions will just be functions and the way the actions receive inputs changes
the inputs change simply to function parameters
**we also need to specify "user server" on top for it to be a server action**
when writing react components server is default
we have to specify "use server" on server actions so that the client components dont feel that the function being made is to a client side function but a server action instead
and then instead of the axios.post we can simply do a function call to the server action with the parameters 
```ts
'user server';  
export async function signup(username: string, password: string) {  
  try {  
    //do bhang bhosda on server  
    return true;  
  } catch (e) {  
    return false;  
  }  
}
```

```tsx
"use client"
import {useState} from 'react';
import {signup} from '..app/actions/user'
export function Signup(){
	const [email,setEmail]=useState('');
	const [pass,setPass]=useState('');
	const handleSignup=async (e)=>{
		e.preventDefault();
		const response=await signup(email,pass);
		console.log(response);
	}
	return (
		 <SignupForm 
			setEmail={setEmail} 
			setPass={setPass} 
			email={email} 
			pass={pass}
			onClick={handleSignup}
		/>
	);
}
```
this logs true on the frontend console
but we wont see anything in the browser network tab because browser doesnt know how to parse the format that server actions use
we can also use this server action at the server level in a server component and that wont be a http call, that will just be a simple function call

another benefit of server actions is that when we do a server action from a client side component then the response is of known type but in case of an http call the response is of type any