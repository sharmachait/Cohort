# Why Next
problems with react
1. at least 2 projects one for frontend and one for backend
2. no built in routing mechanism
3. not SEO optimized
	1. why? because the initial html is empty and is filled up as the user interacts with it, so the dummy bot crawlers are not able to rank SPA, hence not SEO optimized
	2. the content in SPA is dependent on the JS but the crawlers google uses, do not run the JS. they only look at the html
	3. solved because of server side rendering
4. waterfalling problem
	1. the request cycle takes a bunch of steps, even for a simple blob website
![[Pasted image 20240609172413.png]]
	2. all these requests dont happen parallelly
	3. this is known as the waterfalling problem
	4. solved due to server side rendering
## features
1. server side rendering (ssr)
2. API routes - full stack framework
3. file based routing
4. bundle size optimisation
5. static site generation (ssg)
## downsides
1. cant be distributed via a CDN, always needs a server running that does the server side rendering, therefore is expensive (for static sites ofcourse)
2. hard to migrate out of

# init
> npx create-next-app@latest

in it choose typescript, eslint, tailwind, and app router
## page metadata
the name of the tab and description can be exported from every layout page by exporting an object of type Metadata
```tsx
import type {Metadata} from 'next';

export const metadata:Metadata={
	title:"Page Name",
	description:"some description for the page for SEO optimization"
}
```
## file structure
folders inside the app folder will serve as the route and the page.tsx file at the folder level will be served
## server side response
when we go to a route we get the whole ass html for that route in the network tab
## dynamic routes
in a folder named like so `[...param]`
## navigation
### Link
we can use the Link component to navigate to some route, this will create an anchor tag that can be clicked
```tsx
import Link from 'next/link';

export default function home(){
	return <Link href="/some/place/else">someplace else</Link>
}
```

to back in the route like from `some/place/else`to `some/place`
`<Link href="some/place"></Link>`
#### what about dynamic routes?
just use a dynamic f string with the variable `some/place/at/${here}`
#### removing back history
just use the replace attribute of the Link tag
```tsx
import Link from 'next/link';

export default function home(){
	return <Link href="/some/place/else" replace>someplace else</Link>
}
```
hitting back now will take us to the home page
### styling active links different from the other ones
to get the current active link Next.js provides us a hook called usePathname
it can only be used in client components
```tsx
'use client'

import Link from 'next/link';
import { usePathname } from 'next/navigation';

const navLinks = [
  { name: 'register', href: '/register' },
  { name: 'login', href: '/login' }
];

const StyleLinks = ({ link, pathname }) => {
  const isActive = pathname.startsWith(link.href);

  return (
    <Link href={link.href} key={link.name}
      className={isActive ? "font-bold mr-4" : "text-blue-500 mr-4"}
    >
      {link.name}
    </Link>
  );
}

export default function Page({ children }) {
  const pathname = usePathname();

  return (
    <div>
      {navLinks.map(link => (
        <StyleLinks key={link.name} link={link} pathname={pathname} />
      ))}
      {children}
    </div>
  );
}

```

### navigating programmatically
next.js provides another client side hook to do so called the useRouter hook from next/navigation
```tsx
'useClient'
import {useRouter} from 'next/navigation';
export default function page(){
	const router=useRouter();
	const navigateButton=()=>{
		console.log("navigating");
		router.push('/');
	}
	return (
		<>
			<button onClick={navigateButton}>navigate</button>
		</>
	)
}
```
if we want to replace the navigation history instead of the `push('/')` function use the `replace('/')` function
to go back one page programmatically use the `router.back()` function
use the `router.forward()` function to go one page forward
## layout.tsx file
used to wrap child pages in some logic
the layout file must default import a function like the other page files
the function must expect `Readonly<{children:React.ReactNode}>`, this refers to the component being exported from the page.tsx at the same level
basically wrap the child it received in some other html and logic and return wrapper jsx for the children
we can have layout.tsx at the same level as the page.jsx
describes the layout for all the subfolders from that level
can be used for stuff like nav bars
## loading.tsx
showed to the users until data loads for the page.tsx.
page.tsx must be asynchronous
suspense for page.tsx when we await something directly in the page.tsx
## not-found
we can have a custom not found page by creating a file called `not-found.tsx` inside the app directory. We must follow this naming convention for it to work. The not found file must export default a function called NotFound()
but at times we may need to display this page programmatically, to do that we Next.js provides us the notFound function, simply call it in your code when some condition is satisfied
we can have multiple not-found.tsx files at different levels and it will be served accordingly at different urls
## file colocation
we can have flexibility in our file and folder structure and still get our app router to work as we want
a path is not publicly accessible until it has a page.tsx file in it, there fore we can have other files in a folder as well without them being served
## private folders
are not considered by the router
to make a folder a private folder simply prefix its name with an underscore
if we want to use an underscore in the URL segments we can prefix the folder name with ‘%5f’, which is the URL encoded form of an underscore
## route groups
grouping routes and files without affecting the URL segments
keep the files in `(folderName)`
another usecase of a route group can be to apply a layout to certain pages
## metadata
nextjs provides a metadata api for SEO
ways to configure metadata
1. export statis metadata object
2. export a dynamic generateMetadata function
#### metadata rules
1. both the layout and page can export metadata
	1. if defined in the layout it applies to all the pages under that layout
2. metadata is read in order from the root level to the final page level
3. when metadata across multiple places they get combined but page metadata takes precedence over layout metadata if both have the same properties
for dynamic metadata
```tsx
import {Metadata} from 'next';
type Props = {
	params:{
		productId:string;
	}
}
export const generateMetadata = ({params}:Props):Metadata=>{
	return {
		title:'Product ${params.productId}'
	}
}

export default function Page({params}:Props){
	return (<h1>hi</h1>);
}
```
the generateMetdata function can also be asynchronous
![[Pasted image 20240622000003.png]]

## server components
in next all components are server components by default.
they have the ability to read files or fetch data from database on the server
cant use hooks or handle user interactions
## client components
necessary to add the use client on top of the component file
can use hooks and manage interactions
### **we cant have on click handlers in the server side components and by default everything is server side in next.js**

if you want interactivity in a page put the `use client` directive on top of the file

server side components can not be children of client side components
## components folder
we dont want every tsx file to be routed
like simple button or navbar components for that use the components folder to make files for them, they wont be routed by next.js
we can actually name the folder anything just make sure to include that folder in the tailwind config
## routing
everything in the app folder is routed
### shared layouts
![[Pasted image 20240610111327.png]]
##### shared layouts without the `auth` being in the route
if we want a folder to not be part of the route use `(auth)`
![[Pasted image 20240610111606.png]]
now we can go to `app/signin` and all the routes under `(auth)` will have the same layout because 

to make the app router completely ignore a folder for routing name it with a preceding underscore
### dynamic routes
use the folder name like `[paramName]`
the paths to the page.tsx should look like 

`app/product/[id]/page.tsx`

now the page.tsx will be rendered for any value at `[id]`

we can access the value of the id param in the page.tsx at that level like so

```tsx
type paramsType = {params:{id:string}};
export function ProductDetails({params}:paramsType){
	return (
		<h1>
			{params.id}
		</h1>
	);
}
```
#### nested dynamic routes
for stuff like `domain/products/1/reviews/1`

in the page.tsx at the `products/[productId]/review/[reviewId]` we can access both the parameters

```tsx
type paramsType={
	params:{
		productId:stirng,
		reviewId:stirng
	}
}
export default function ReviewDetails({params}:paramsType){
	return (
		<h1>
			<h2>
				{params.productId}
			</h2>
			<h2>
				{params.reviewId}
			</h2>
		</h1>
	);
}
```

### Catch All Segments
when we have too much nesting but all the pages will share the same layout we would still need to create all the folders in the nested path, that is, without catch all segments

if we know our routes well enough and know that they are going to be standard we can create catch all segments for the routes, to handle all the routes in one file
create folder path like this
`docs/[...pages]/page.tsx`
this page.tsx will be rendered for anything and everything with `docs` in the route

in the catch all segment page.tsx we can access all the segments of the url like so
```tsx
type CatchAllType={
	params:{
		slug:string[]
	}
}
export default function CatchAll(params:CatchAllType){
	if(params.params.slug.length==2){
		return (
			<h1>
				viewing docs for feature {params.params.slug[0]} component {params.params.slug[1]}
			</h1>
		);
	}
	else if(params.params.slug.length==1){
		return (
			<h1>
				viewing docs for feature {params.params.slug[0]}
			</h1>
		);
	}
	else{
		return (
			<h1>
				Home Page
			</h1>
		);
	}
}
```

now if we go to localhost:3000/docs/feature/component
or
to localhost:3000/docs/feature
or
to localhost:3000/docs

these cases are handled by our page.tsx

