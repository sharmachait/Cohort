# Why Next
problems with react
1. at least 2 projects one for frontend and one for backend
2. no built in routing mechanism
3. not SEO optimized
	1. why? because the initial html is empty and is filled up as the user interacts with it, so the dummy bot crawlers are not able to rank SPA, hence not SEO optimized
	2. the content in SPA is dependent on the JS but the crawlers google uses, do not run the JS. they only look at the html
	3. solved because of server side rendering
4. waterfalling problem
	1. the request cycle takes a bunch of steps, even for a simple blob website
![[Pasted image 20240609172413.png]]
	2. all these requests dont happen parallelly
	3. this is known as the waterfalling problem
	4. solved due to server side rendering
## features
1. server side rendering (ssr)
2. API routes - full stack framework
3. file based routing
4. bundle size optimisation
5. static site generation (ssg)
## downsides
1. cant be distributed via a CDN, always needs a server running that does the server side rendering, therefore is expensive (for static sites ofcourse)
2. hard to migrate out of

# init
> npx create-next-app@latest

in it choose typescript, eslint, tailwind, and app router
## page metadata
the name of the tab and description can be exported from every page by exporting an object of type Metadata
```tsx
import type {Metadata} from 'next';

export const metadata:Metadata={
	title:"Page Name",
	description:"some description for the page for SEO optimization"
}
```
## file structure
folders inside the app folder will serve as the route and the page.tsx file at the folder level will be served
## server side response
when we go to a route we get the whole ass html for that route in the network tab
## dynamic routes
in a folder named like so `[...param]`
## layout.tsx file
used to wrap child pages in some logic
the layout file must default import a function like the other page files
the function must expect `Readonly<{children:React.ReactNode}>`, this refers to the component being exported from the page.tsx at the same level

basically wrap the child it received in some other html and logic and return wrapper jsx for the children

we can have layout.tsx at the same level as the page.jsx
describes the layout for all the subfolders from that level

can be used for stuff like nav bars
## server components
in next all components are server components by default.
they have the ability to read files or fetch data from database on the server
cant use hooks or handle user interactions
## client components
necessary to add the use client on top of the component file
can use hooks and manage interactions
## routing
everything in the app folder is routed
#### shared layouts
![[Pasted image 20240610111327.png]]
#### shared layouts without the auth being in the route
if we want a folder to not be part of the route use `(auth)`
![[Pasted image 20240610111606.png]]
now we can go to `app/signin` and all the routes under `(auth)` will have the same layout because 
## components page
we dont want every tsx file to be routed
like simple button or navbar components for that use the components folder to make files for them, they wont be routed by next.js
we can actually name the folder anything just make sure to include that folder in the tailwind config

### **we cant have on click handlers in the server side components and by default everything is server side in next.js**

if you want interactivity in a page put the `use client` directive on top of the file

server side components can not be children of of client side components
## backend
in next we fetch the data on the server side and pre render the page before returning it to the user
we can still do api calls for external apis
using useEffects will require us to make the component a client side component

#### server side data fetching and loaders
done using async components
```tsx
import axios from 'axios';  

const Page = async () => {  
	const res = await axios.get(  
		'https://week-13-offline.kirattechnologies.workers.dev/api/v1/user/details'  
	);  
	const data = res.data;  
	return (
		<div>
			{data.name}
		</div>
	);  
};  

export default Page;
```

notice the component function itself in asynchronous

the server side request may take a long time, and the client will have nothing to show in the meantime
add a spinner, **without hooks**
use a file called loading.tsx at the same level as the page.tsx server component
```tsx
const loading = () => {  
  return <div>loading...</div>;  
};  
export default loading;
```
![[Pasted image 20240611074417.png]]
we can see the effects clearly by adding an awaited time out int he function fetching our data
```tsx
await new Promise((r) => setTimeout(r, 5000));
```
like so
```tsx
import axios from 'axios';  
const Page = async () => {  
  const res = await axios.get(  
    'https://week-13-offline.kirattechnologies.workers.dev/api/v1/user/details'  
  );  
  await new Promise((r) => setTimeout(r, 5000));  
  const data = res.data;  
  return <div>{data.name}</div>;  
};  
export default Page;
```

#### Api in next.js
in the app folder create an api folder in that create a controller name folder like `app/api/user`
in that folder create a route.ts
this file will be treated as an api route because of the route.ts
in that file export a function called GET which will be the function where we receive control
```ts
import {NextResponse} from "next/server";  
  
export function GET() {  
  return NextResponse.json({  
    name: 'chaitanya',  
  });  
}
```
for body, headers, query parameters receive an object of type NextRequest in the function
but even without that we can go to 
`localhost:3000/api/user`
in the same file if we create a POST function we get a post endpoint at the same route
```ts
import { NextRequest, NextResponse } from 'next/server';  
  
export function GET() {  
  return NextResponse.json({  
    name: 'chaitanya',  
  });  
}  
  
export async function POST(req: NextRequest) {  
  let body = await req.json();  
  console.log({ body });  
  console.log(req.headers.get('token'));  
  console.log(req.nextUrl.searchParams.get('filter'));  
  return NextResponse.json({  
    name: 'chaitanya',  
  });  
}
```

as you can see we can get the 
- body using the `req.json()` function which returns a promise
- header params via `req.headers.get("key")`
- query parameters using `req.nextUrl.searchParams.get('filter')`
