## initializing prisma
> npm i prisma @types/node ts-node
> npx prisma init

this creates a prisma folder with schema.prisma file
```ts
// This is your Prisma schema file,
// learn more about it in the docs: https://pris.ly/d/prisma-schema
  
// Looking for ways to speed up your queries, or scale easily with your serverless or edge unctions?
// Try Prisma Accelerate: https://pris.ly/cli/accelerate-init
  
generator client {
  provider = "prisma-client-js"
}
  
datasource db {
  provider = "postgresql"
  url      = "connection string"
}
```
we can change the type of DB by simply changing the provider and the URL
### Connection String

- The connection string is a vital piece of information that your application uses to connect to the database. It includes the username, password, host, port, and database name.

- Format:

`postgresql://[user]:[password]@[host]:[port]/[database]?[options]`

- This format is similar to what you might have seen with MongoDB and Mongoose, where the connection string is used to establish a connection to the database from your application code.

### Understanding the Connection String Components

- `**postgresql://**` This is the protocol indicating that you are connecting to a PostgreSQL database.

- `**username:password**` Credentials for authenticating with the database.

- `**host**` The server where the database is hosted (e.g., localhost, a remote server, or a cloud service like Neon).

- `**port**` The port number on which the PostgreSQL server is listening (default is 5432).

- `**database**` The specific database you want to connect to.

- `**options**` Additional connection options such as SSL mode.
## creating models
```ts
model User {  
  id    Int     @id @default(autoincrement())  
  email String  @unique  
  firstName  String?  
  lastName  String?  
  password String?
}  
  
model Todo {  
  id     Int   @id @default(autoincrement())  
  title String  
  done Boolean @default(false)  
  description String?  
  user_id Int
}
```
where Post needs to be another model
the question mark makes the field optional
if you want to add another field to the user table later on make sure its optional because the old entries wont have value for that column, or would have to provide a default value in the model
### migrating the changes to the database
> npx prisma migrate dev --name UserAndTodoAdded

this will create the migration files locally and apply my changes to a database

to be able to apply migrations the database must already exist
the annotation @id creates a primary key constraint in the migration

prisma maintains the migrations that have been applied to the database in its own table `_prisma_migrations`
## prisma clients
clients provide the API to actually query the database basically the DBcontext
clients are autogenerated 
> npx prisma generate

we can now start using the client with the following
```ts
import { PrismaClient } from '@prisma/client'
const repositoryProvider = new PrismaClient()
```
this will provide us access to the model repositories like unit of work
```ts
repositoryProvider.user// if we had a user model
```
this will give us access to all the repository functions to find update delete and insert
so anytime you make changes to the schema.prisma file we should apply the migrations and regenerate the client with the following commands
> npx prisma migrate dev --name UserAndTodoAdded
> npx prisma generate

### create
we can do crud operations like so
```tsx
import { PrismaClient } from '@prisma/client'
const repositoryProvider = new PrismaClient()

async function createUser(username:string,firstName:string,lastName:string,passwordHash:string){  
  
    const res=await repositoryProvider.user.create({  
        data: {  
            email:username,  
            firstName:firstName,  
            lastName:lastName,  
            password:passwordHash,  
        }
    });  
    console.log(res);  
}
createUser("chait812s6@gmail.com","chaitanya","sharma","somsehash")  
```
this will create a user row in the database, of course these functions return a promise so are awaitable
this would printout an object of the type User with the id included
```json
{
  id: 1,
  email: 'chait8126@gmail.com',
  firstName: 'chaitanya',
  lastName: 'sharma',
  password: 'somehash'
}
```
but why data?
because we can specify other properties as well that define what the create function returns via the select property
```ts
async function createUser(username:string,firstName:string,lastName:string,passwordHash:string){  
  
    const res=await repositoryProvider.user.create({  
        data: {  
            email:username,  
            firstName:firstName,  
            lastName:lastName,  
            password:passwordHash,  
        },        
        select:{  
            email:true,  
            id:true  
        }  
    });  
    console.log(res);  
}
```
if we run the createUser for a username that already exists in the database it wont be added to the database, but the autoincrement function will still be called and increase the id for that try to insert so one erroneous query will make us skip the id by 1
### update
```ts
import { PrismaClient } from '@prisma/client'
const repositoryProvider = new PrismaClient()

type updateParams ={  
    firstName:string,  
    lastName:string  
}  
  
async function updateUser(username:string, params:updateParams){  
    const res=await repositoryProvider.user.update({  
        where:{  
            email:username,  
        },        
        data:{  
            firstName:params.firstName,  
            lastName:params.lastName,  
        }    
    });    
    console.log(res);  
}  
updateUser("chait812s6@gmail.com",{firstName:"Kanhaiya",lastName:"Bhayana"})
```
this prints out everything in the user object
we can use select here as well to narrow down what is returned

### Read
```ts
import { PrismaClient } from '@prisma/client'
const repositoryProvider = new PrismaClient()

async function getUserByUsername(username:string){  
    const res=await repositoryProvider.user.findFirst({  
        where:{  
            email:username,  
        }  
    });    
    console.log(res);  
}  
getUserByUsername("chait812s6@gmail.com");
```
we have the option for other find functions as well like findMany and findUnique

### Delete
```ts
async function deleteByUsername(username:string){  
    const res=await repositoryProvider.user.delete({  
        where:{  
            email:username,  
        }    });    console.log(res);  
}  
deleteByUsername("chait812s6@gmail.com")
```

## Relationships using foreign keys
#### one to many without constraints
```ts
model User {
	id Int @id @default(autoincrement())
	username String @unique
}
model Todo {
	id Int @id @default(autoincrement())
	Title String
	userId Int
}
```
