- fetch returns a promise and we can use the .then() syntax with it
```js
function getAnimalData(){
	fetch("https://fakerapi.it/api/v1/persons")
	.then(function(response){
		response.json()//convert response to json, returns a promise
		.then(function(data){
			setData(data.data);
			console.log(data.data);
		});
	});
}
```

in async await syntax
```js
async function getData(){
	const res=await fetch("https://fakerapi.it/api/v1/persons");
	const json=await res.json();
	console.log(json.data);
}
```
##### cryptography jargon
1. hashing - one way encryption
2. encryption - can be decrypted, requires a key, a secret
3. JWT - some encryption function that only works for json input, can be decoded by anyone but can be verified using only the password, technically its a digital signature
4. Local storage - 
		==1. localStorage.setItem(key, val);== 
		==2. localStorage.getItem(key);==

#### working with JWT
1. external dependency jsonwebtoken
> npm install jsonwebtoken
2. functionalities needed like creating jwt and verifying jwt are provided by this library
```js
const jwt=require("jsonwebtoken");
let token=jwt.sign(json,secret);

let decodedJson=jwt.verify(token,secret);
decodedJson.propertiesClaimed
```

3. if the data received if json we cant simply add it to the inner html of some tag, we first have to strigify it using the JSON library
```js
document.getElementById("userData").innerHTML = JSON.stringify(data);
```

### databases
in mongo land, database server == cluster
table == collection
database == set of collections
#### mongoose library is used to connect JS to mongoDB

following is the most basic mongoose connection to mongoDB
```js
const mongoose =require("mongoose");
mongoose.connect("connection string/database name");

const Cat=mongoose.model("Cat",{name:String});
const kitty=new Cat({name:"shailja"});
kitty.save().then(()=>console.log("meow"));

we can also create a cat record like so

await Cat.create({name:"shailja"});
```

if we have a model defined we can look for it via
```js
cat.findOne({name:"some name"});//can be any one of the properties of the record
```

example of a basic post endpoint that stores data in a database
```js
const mongoose = require("mongoose");
const express = require("express");
const jwt = require("jsonwebtoken");
const jwtPassword = "123456";
const app = express();
app.use(express.json());
mongoose.connect("mongodb+srv://chait8126:<mongopassword>@cohortdb.g0dltte.mongodb.net/user_app");
  
const User = mongoose.model("User", { name: String, email: String, password: String });
 

app.post("/signup", async (req, res) => {
    const username = req.body.username;
    const password = req.body.password;
    const name = req.body.name;
  
    const existingUser = await User.findOne({ email: username });
    if (existingUser) {
        return res.status(400).send("username already exists");
    }
    const user = new User({
        name: name,
        email: username,
        password: password
    });
  
    await user.save();
    res.status(201).json({
        msg: "user created succesfully "
    })
});
  
app.listen(3000);
```
#### schemas in mongoose
```js
const UserSchema=new mongoose.Schema({
	email:String,
	password:String,
	purchasedCourses:[{
		type: mongoose.Schema.Types.ObjectId,
		ref: 'Course'
	}]
});
const CourseSchema = new mongoose.Schema({
	title: String,
	price:6000
});

const user=mongoose.model('User',UserSchema);
const course=mongoose.model('Course',CourseSchema);
```
to define relationships in mongo db  we have to use the following syntax, which will store reference to other collections
```js
purchasedCourses:[{
	type: mongoose.Schema.Types.ObjectId,
	ref: 'Course'
}]
```
mongo DB creates an id for all the object stored in it, can be used to uniquely identify the objects

#### create
using the models we can write data in the database
```js
const UserSchema=new mongoose.Schema({
	email:String,
	password:String,
});
const user=mongoose.model('User',UserSchema);
await user.create({
	username:req.body.username,
	password: req.body.password
});
```

when we create some data we can get the object created back if we await it or .then it
```js 
const course = await Course.create({
        title: title,
        description: desc,
        price: price,
        imageLink: imageLink
    });
res.status(200).json({ msg: "created", id: course._id });
```
#### read
```js 
user.findById("1");
user.findOne({
	username:"chait8126@gmail.com"
});
user.find({
	username: "chait8126@gmail.com"
});
```
### populating from other collection
if we have added reference in a schema like so 
```js
const mongoose = require('mongoose');
const { Schema, model } = mongoose;
  
const PostSchema = new Schema({
    author: {
        type: mongoose.Schema.Types.ObjectId,
        ref: 'User'
    }
});

const PostModel = model('Post', PostSchema);
module.exports = PostModel;
```
where User is defined so
```js
const mongoose = require('mongoose');

const userSchema = new mongoose.Schema({
    username: { type: String, required: true, min: 4, unique: true },
    password: { type: String, required: true, }
});
  
const UserModel = mongoose.model('User', userSchema);
  
module.exports = UserModel;
```

we can fetch the user data while fetching the post data like so
```js
  await PostModel.find().populate('author',['username']);
```
the list in the populate function is a list of properties we want to be fetched from the other collection
#### update
```js
user.updateOne(
	{"id":"1"},
	{$push: {purchasedCourse:courseId}}
);
```
this will be used to push a new course to the courses array of the user where the schema for the user be the following
```js
const UserSchema=new mongoose.Schema({
	email:String,
	password:String,
	purchasedCourses:[{
		type: mongoose.Schema.Types.ObjectId,
		ref: 'Course'
	}]
});
```
to update simple properties
```js
user.updateOne({id:"1"},{password: "new password"});
user.update({},{premium:true})
```
this will find the objects that match the first json update the properties provided in the second json
#### delete
```js
user.deleteMany({});
user.deleteOne({username:"chait8126@gmail.com"});
```
	
### authentication
we will create a middleware to handle authentication for us after signup and sign in

#### mongo shell
some common commands
1. to open the mongo shell
	1. mongosh
2. to show all the databases
	1. show dbs
3. switch to a database with
	1. use [name]
4. we are allowed to switch to any database even if it doesnt exist
5. a database is not created just by switching to it
switch to a database
1. to show all collections
	1. show collections
2. db.createCollection("name")
3. db.name.drop()


### cookie
we can respond back with cookie like so
```js
res.status(200).cookie("token", token).json('ok');
```
and it is set in the response header

but to be able to this we have to specify this in the cors configuration like so
```js
app.use(cors({ credentials: true, origin: 'http://localhost:5173' }));
```

in the frontend we need to receive the cookie like so
```js
let response = await fetch("http://localhost:3000/login", {
            method: "POST",
            headers: {
                "Access-Control-Allow-Origin": "*",
                "Access-Control-Allow-Methods": "POST, GET, OPTIONS, DELETE",
                "Content-Type": "application/json"
            },
            body: JSON.stringify({ username, password }),
            credentials: 'include',
        });
```
[[1. Node runtime]]