not as simple as multiple folders in one folders
multiple projects in the same folder that share code, how they are built how the shared code must be hosted somewhere need to be done incase not monorepo
### benefits of monorepos
1. shared code reuse
2. enhanced collaboration
3. optimized Builds and CI/CD, with tools like turbo repos
4. Centralized Tooling and Configuration

### MonoRepo frameworks
1. lerna
2. Turborepo not exactly a framework
turbo repo either sets up NX or Yarn workspaces under the hood which are turbo repo frameworks
### Build System VS Build System Orchestrator vs Monorepo framework
##### build systems include transpilation, bundling and minification
##### Monorepo Framework provides tools for managing projects that contain multiple projects, including dependency management and workspace configuration
##### Turbo repo is a build system orchestrator, it allows us to define tasks in our monorepo for transpilation, bundling, minification or tests, via other tools like tsc or vite

Turbo repo takes care of things like building the common modules before the modules or projects that depend on that common module.
it orchestrate the build process
as it understand the dependency graph it can also help us parallelize the build process
it can also cache the build process so its faster

### init
> npx create-turbo@latest

this creates 5 modules
1. apps/web - next.js webstie
2. apps/docs - docs website for all the documentation of the project
3. packages/ui - ui packages
4. packages/typescript-config - shared TS config
5. packages/eslint-config - shred ESLint config

> npm i
> npx next telemetry disable
> npm run dev

the packages/ui module will have the name `@repo/ui` in the package.json
which is a path alias for this module???????

also in the package.json we have the exports section to specify what all files are allowed to be exported

we can import from this module if it has name `@repo/ui` and an export at path `"./button":"./src/button.tsx"` like so
```tsx
import {button} from '@repo/ui/button'
```
so the name of the module along with the exports defined in the package.json together form the path alias for components
also in the projects using these components being exported from `@repo/ui` we must include `@repo/ui` as a dependency in the package.json of that project like so
![[Pasted image 20240615151114.png]]
we might need to add the packages/ui folder manually into the tailwind config like 
`../../packages/ui/**/**.tsx`

turbo repo also provides us with remote caching so if the code hasn't changed in a commit it simply uses the artifact saved in some blob storage

### generators
its pretty tedious to add all the components in the package.json for each ui component that we create
![[Pasted image 20240616133712.png]]
to solve this exact problem turbo repo provides us with generators
the `generate:component` script in the above image is used to add the components in the turbo folder to the package.json and create the react component out of the generator code

the command` npm run generate:component `has to be ran in the UI folder
it asks for the name of the component we want to create, it creates the component that we can customize to our liking

### turbo.json
configuration for the turbo repo
![[Pasted image 20240616170220.png]]
in this context he build pipeline is used when we do npm run dev in the root folder the `^build` means that turborepo needs to build all the individual modules
the outputs property defines the binary directory and the location of the cache of the build and because next also caches we have to specify to not look into the next.js caches