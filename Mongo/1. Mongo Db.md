### databases
in mongo land, database server == cluster
table == collection
row == document
database == set of collections
#### mongoose library is used to connect JS to mongoDB

following is the most basic mongoose connection to mongoDB
```js
const mongoose =require("mongoose");
mongoose.connect("connection string/database name");

const Cat=mongoose.model("Cat",{name:String});


const kitty=new Cat({name:"shailja"});
kitty.save().then(()=>console.log("meow"));

we can also create a cat record like so

await Cat.create({name:"shailja"});
```

the mongoose.connect function takes two optional callback functions
```js
mongoose.connect('connection string',
				 ()=>{console.log('connected')},
				 (e)=>{console.log("error "+e)});
```

if we have a model defined we can look for it via
```js
cat.findOne({name:"some name"});//can be any one of the properties of the record
```

example of a basic post endpoint that stores data in a database
```js
const mongoose = require("mongoose");
const express = require("express");
const jwt = require("jsonwebtoken");
const jwtPassword = "123456";
const app = express();
app.use(express.json());
mongoose.connect("mongodb+srv://chait8126:<mongopassword>@cohortdb.g0dltte.mongodb.net/user_app");
  
const User = mongoose.model("User", { name: String, email: String, password: String });
 

app.post("/signup", async (req, res) => {
    const username = req.body.username;
    const password = req.body.password;
    const name = req.body.name;
  
    const existingUser = await User.findOne({ email: username });
    if (existingUser) {
        return res.status(400).send("username already exists");
    }
    const user = new User({
        name: name,
        email: username,
        password: password
    });
  
    await user.save();
    res.status(201).json({
        msg: "user created succesfully "
    })
});
  
app.listen(3000);
```
#### schemas in mongoose
a model is an object that follows some schema
```js
const UserSchema=new mongoose.Schema({
	email:String,
	password:String,
	purchasedCourses:[{
		type: mongoose.Schema.Types.ObjectId,
		ref: 'Course'
	}]
});
const CourseSchema = new mongoose.Schema({
	title: String,
	price:6000
});

const user=mongoose.model('User',UserSchema);
const course=mongoose.model('Course',CourseSchema);
```

here "User" and "Course" will be collections in mongo DB

to create a document in the user collection
```js
let userdoc=new user({
	email:"chait8126@gmail.com",
	password:"some salt encrypted password"
	purchasedCourses:[
		coursedoc._id
	]
});
await userdoc.save();

//or

const userdoc=await user.create({
	email:"chait8126@gmail.com",
	password:"some salt encrypted password"
	purchasedCourses:[
		coursedoc._id
	]
});

userdoc.email="changed";
await userdoc.save();
```
to define relationships in mongo db  we have to use the following syntax, which will store reference to other collections
```js
purchasedCourses:[{
	type: mongoose.Schema.Types.ObjectId,
	ref: 'Course'
}]
```
mongo DB creates an id for all the object stored in it, can be used to uniquely identify the objects

#### create
using the models we can write data in the database
```js
const UserSchema=new mongoose.Schema({
	email:String,
	password:String,
});

const user=mongoose.model('User',UserSchema);

await user.create({
	username:req.body.username,
	password: req.body.password
});
```

when we create some data we can get the object created back if we await it or .then it
```js 
const course = await Course.create({
        title: title,
        description: desc,
        price: price,
        imageLink: imageLink
    });
res.status(200).json({ msg: "created", id: course._id });
```

### complex schemas
```js
const UserSchema=new mongoose.Schema({
	name:String,
	age:Number,
	email:String,
	createdAt:Date,
	hobbies:[String],
	address:{
		houseNo:Number,
		street:String
	},
	bestFriend:mongoose.SchemaTypes.ObjectId
});
```

we can separate out the Address Schema from the User Schema
```js
const AddressSchema=new mongoose.Schema({
	Street:String,
	City:String
})

const UserSchema=new mongoose.Schema({
	name:String,
	age:Number,
	email:String,
	createdAt:Date,
	hobbies:[String],
	address:AddressSchema,
	bestFriend:mongoose.SchemaTypes.ObjectId
});
```

==doing this will create an id for address as well==

Schemas like these only provide basic type checking in the name of validation
we can actually do complex validation checks on the data
like so
```js
const UserSchema=new mongoose.Schema({
	name:String,
	email:{
		type:String,
		require:true,
		lowercase:true//this converts the data to lowercase instead of checking if the data is lowercase
	},
	date:{
		type:Date,
		default: new Date()//but this date is only computed once at the time of creation of this schema for dynamic default values use ()=>{}
	}
});
```
the default value in the above example is only computed once when the schema is created to actually get a dynamic default value we will have to use a function
```js
const UserSchema=new mongoose.Schema({
	name:String,
	email:{
		type:String,
		require:true,
		lowercase:true
	},
	date:{
		type:Date,
		default: ()=>new Date()
	}
});
```
#### read
```js 
user.findById("1");
user.findOne({
	username:"chait8126@gmail.com"
});
user.find({
	username: "chait8126@gmail.com"
});
```
### populating from other collection
if we have added reference in a schema like so 
```js
const mongoose = require('mongoose');
const { Schema, model } = mongoose;
  
const PostSchema = new Schema({
    author: {
        type: mongoose.Schema.Types.ObjectId,
        ref: 'User'
    }
});

const PostModel = model('Post', PostSchema);
module.exports = PostModel;
```
where User is defined so
```js
const mongoose = require('mongoose');

const userSchema = new mongoose.Schema({
    username: { type: String, required: true, min: 4, unique: true },
    password: { type: String, required: true, }
});
  
const UserModel = mongoose.model('User', userSchema);
  
module.exports = UserModel;
```

we can fetch the user data while fetching the post data like so
```js
  await PostModel.find().populate('author',['username']);
```
the list in the populate function is a list of properties we want to be fetched from the other collection
#### update
```js
user.updateOne(
	{"id":"1"},
	{$push: {purchasedCourse:courseId}}
);
```
this will be used to push a new course to the courses array of the user where the schema for the user be the following
```js
const UserSchema=new mongoose.Schema({
	email:String,
	password:String,
	purchasedCourses:[{
		type: mongoose.Schema.Types.ObjectId,
		ref: 'Course'
	}]
});
```
to update simple properties
```js
user.updateOne({id:"1"},{password: "new password"});
user.update({},{premium:true})
```
this will find the objects that match the first json update the properties provided in the second json
#### delete
```js
user.deleteMany({});
user.deleteOne({username:"chait8126@gmail.com"});
```

