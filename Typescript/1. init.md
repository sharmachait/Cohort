# Initialize A Project
> npm install -g typescript
> 
> npm init -y
> 
> npx tsc --init

or

> tsc --init

this creates a ts.config file with variables which we can turn on or off which will change our compilation process
# Compile
create a file called main.ts then
> tsc main.ts

or
> tsc main.ts main.js

this creates a ffile called main.js, if we dont provide a js file name it creates the file with the same name as the ts file
to set compiling as a hot reload feature use
> tsc main.ts -w

watches only the  main.ts file

> tsc -w

watches all the files

==when we delete a *.ts file  we need to manually delete the *.js file it was compiled into ==
Alternatively, you could clean the `/dist` folder before each build, which would ensure that it only contains the compiled JavaScript for existing TypeScript files. This can be done by adding a `clean` script in your `package.json` file that deletes the `/dist` folder, which is run before your `build` script.
```json
{
  "scripts": {
    "clean": "rimraf ./dist",
    "prebuild": "npm run clean",
    "build": "tsc -b"
  }
}
```

# Ts Config
1. "target" option - specifies the ecmascript target version the ts compiler should convert to
2. "rootDir"/"outDir" - this option specifies where the compiler should start looking for the ts files, because we dont want the TS files and the auto generated Js files in the same folder use the rootDir option to tell TSC where to look for TS files and the outDir option to where to put the JS files. we can create the SRC and the DIST folder and specify them in the config. (It is generally a good idea to put the dist folder in the gitignore file)
```ts
"rootDir":"./src",
"outDir":"./dist",
```
and then we can run the code with 
> node dist/main.js

3. "noImplicitAny" - by default is true, doesnt allow implicit any types. can be set to true to allow
4. "removeComments":true - removes comments while transpiling
5. "include" - to specify which files should be compiled, lets say to compiler only the files in the src folder
6. "exclude" - we can also exclude certain files
```json
{
	"compilerOptions":{
	},
	"include" : ["src"],
	"exclude" : ["**/*.src.spec.ts"]
}
```
7. "noEmitOnError":true - to stop the compiler from compiling in case of a typescript error
# Basic Types for native features
```ts
const x: number =1;
console.log(x);
```
we dont have to initialize variables with types, we can simply declare them and use later on
```ts
let name:string;
name="chaitnaya";
```
##### **Typescript types
- number
- string
- boolean 
- null
- undefined
## union types |

```ts
let a: number | string = 1;
a = '2';
```
## Function definitions
***we cant have the same function signature (name and parameters and return types) in two files in the same directory they have to be unique folder wise, why? because of something known as ==ambient modules== , if we export them they will be fine, if we dont they become ambient modules and are confused by the typescript compiler*****
 
### Type definitions for function parameters
```ts
function testing(name: string){
	console.log(name);
}
```
if no type is defined it implicitly takes the any type
technically the correct way for any function is to include the return type as well
```ts
function testing(a: string): void {
	console.log(name);
}
```
we can define return types with 
```ts
function testing(a: number, b: number): number {
	return a+b;
}
```
even if i dont mention the return type typescript will be able to do basic type inference
### Callback function type definition
```ts
function runAfter1(callback: ()=> void): void{
	setTimeout(callback,1000);
}
```
here the callback function it can accept is a function with no parameters and returns void
### Arrow functions
```ts
const sum = (a:number ,b:number):number=>{
	return a+b;
}
```
## Objects
if we do the following
```js
let obj:object;
```
we can then do the following without typescript complaining
```ts
obj=[];
```

for better constraints choose the following syntax, to define an object with only string keys and number vals
```ts
let obj:{[key,string]:string};
obj={
	key1:1,
	"key2":2
}
```

if we allow typescript to infer the types, it will fix types to properties
```ts
let obj = {a:1,b"true",c:false};
obj.a=false;
//~~~~~~~~~~~ boolean not assignable to number
```
## Arrays
doesnt allow pushing a number to a string[]
when we declare an array with string[] the length and the order of the element doesnt matter
but if we want to be more specific with our constrictions , where some definite type is locked in at certain indexes, or arrays of definite length we can choose the following syntax AKA tuples
```ts
let myTuple:[string,number,boolean];
```
now myTuple can only be length 3 and only have string at [0] number at [1] and boolean at [2];
if we choose the original syntax our array would have to be declared like so
```ts
let myTupleArray:(string | number | boolean)[];
```
the length of this array is not checked my typescript neither is the order of the elements therefor we cant do the following
```ts
myTuple=myTupleArray;
//~~~~~~~~~~~~~~~~~~~~ type not assignable to other type

myTupleArray=myTuple;//no issues
```

we also cant set the index that is out of bound for the tuple
## Reg ex
```ts
let re:RegExp=/\w+/g;
```

# Interfaces and types
## objects with non homogeneous values
basic syntax
```tsx
interface User{
	name:string;
	email:string;
	age:number;
}
```
interfaces with optional properties using question mark
```tsx
interface User{
	name:string;
	email:string;
	age?:number;
}

type Guitarist = {
  name: string,
  active?: boolean,
  albums: (string[] | number)
}

let bonJovi:Guitarist={
  name: "jon bonjovi",
  active:false,
  albums:10
} 
```

another way is to union the type with undefined
```ts
interface Guitarist {
  name: string,
  active:boolean | undefined,
  albums:(string[] | number)
}
```
==if we make some property optional. then we cant use the functions of that property’s type==
==for instance if we make name an optional string then we cant call string functions on it unless we check for undefined before==
```ts
interface Guitarist {
  name?: string,
  active:boolean ,
  albums:(string[] | number)
}

let a: Guitarist={
  active:false,
  albums:10
}

//we can still log it 
console.log(a.name); //output undefined
// but we cant call string functions on it anymore

console.log(a.name.toUpperCase()) //throws an error
//          ~~~~~~~ a.name is undefined

//instead check for undefined before calling the function
console.log(a.name?.toUpperCase())
```
same stands true for types

but if we check the property in an if then typescript is smart enough to realize that control wont reach the line if undefined so it doesnt throw and error
```ts
if(a.name){
  console.log(a.name.toUpperCase());
}
```
## functions that expect an interface / type as parameter
```tsx
function isLegal(user: User): boolean{
	if(user.age>=18)return true;
	return false;
}
```
functions like these can be called like so
```tsx
isLegal({
	name:"chaitanya",
	age:18,
	email:"chait8126@gmail.com"
})
```

so in react when we want to create a component with props create an interface for the props
if we try to render the component with a prop that is  not in the interface it will throw an error on compile time
###### implementing interfaces
interfaces can have functions with functions signature as key and return type as value and classes can implement interfaces
```ts
interface Person{
	name: string;
	age: number;
	great(phrase: string): void;
}

class Employee implements Person {
	name: string;
	age: number;
	
	constructor(n: string, a: number){
		this.name=n;
		this.a=a;
	}
	greate(phrase: string){
		console.log(phrase);
	}
}
```

all the properties that are going to be associated to "this" need to be defined in the class like the name and the age

we can also have public and private access specifiers

if we dont want some property to be defined in the constructor using "this" we cna mark it as an optional property in interface and class both
```ts
interface person {
	name?: string;
}
class employee implements person{
	name?:string;
	constructor(){}
}
```

this is the difference between interfaces and types, ==interfaces can be implemented but types can not be implemented==

we can implement multiple interfaces

we can do inheritance via extends keyword

implement an interface and extend a class 

==one interface can extend another interface==
## types
Used to aggregate data together
```ts
type User = {
	name: string;
	age: number;
}
```
#### what else do types provide?

1. Unions - basically "or" but for type definition
```ts
function takesNumberOrString(id: (number|string)){}
takesNumberOrString(1);
takesNumberOrString("1");
```
in type definitions
```ts
type args= number | string;
function fn(arg: args){}
fn(1);
fn("1");
```

2. Intersection - basically "and" but for type definitions
```ts
type employee={}
type manager={}
type teamLead=employee & manager;
```

we can do these intersections and unions with interfaces as well

```ts
interface Person {
  name: string;
  age: number;
  great?(phrase: string): void;
}
  
type ghatia = {
  hai: boolean;
};
  
type ghatiaadmi = Person & ghatia;
  
type shayadGhatia = Person | ghatia;
  
function isGhatia(admi: ghatiaadmi): void {
  console.log(admi.hai);
}
  
isGhatia({ name: "chaitanya", age: 18, hai: false});
```

what if some property is repeated with different types?
number takes precedence over string so the last line will throw error
```ts
type Person = {
  name: string;
  age: number;
  great?(phrase: string): void;
};
  
type ghatia = {
  hai: boolean;
  age: string;
};
  
type shayadGhatia = ghatia | Person;
  
function isGhatia(admi: shayadGhatia): void {
  console.log(typeof admi.age);
}
isGhatia({ name: "chaitanya", age: 18 });  
isGhatia({ name: "chaitanya", age: "18" });
```

and if we do intersection between the types / interface to create the new type
the resultant age property will have the type of never and wont be settable
```ts
type Person = {
  name: string;
  age: number;
  great?(phrase: string): void;
};
  
type ghatia = {
  hai: boolean;
  age: string;
};
  
type ghatiaadmi = Person & ghatia;
  
function isGhatia(admi: ghatiaadmi): void {
  console.log(typeof admi.age);
}
  
isGhatia({ name: "chaitanya", age: "18" });
```
![[Pasted image 20240316145222.png]]
therefor no matter what, we can call this function

when ever we do an intersection or a union the resultant is a type

## Arrays
making an array of a type is as simple as adding [] next to the type

```ts
let arr: number[]=[]; 
type numberArr=number[];
```

### abstract classes
can have code in the functions while other functions can be defined as abstract